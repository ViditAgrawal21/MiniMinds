// src/data/questionData.ts
// Dynamic question data loader
import { t } from "@/i18n/locales/i18n";
import questionDatabase from "./questionDatabase.json";

interface QuestionOption {
  "Option 4 Weight": string;
  "Option 5": string;
  "Option 1": string;
  "Option 2": string;
  "Option 3 Weight": string;
  "Option 3": string;
  Q_id: string;
  "Option 1 Weight": string;
  "Option 4": string;
  "Option 5 Weight": string;
  filename: string;
  Name: string;
  "Option 2 Weight": string;
}

interface QuestionSet {
  [scanType: string]: QuestionOption[][];
}

interface QuestionData {
  conditions: {
    [key: string]: {
      questions: Array<{
        text: string;
        scores: {
          stronglyAgree: number;
          agree: number;
          neutral: number;
          disagree: number;
          stronglyDisagree: number;
        };
      }>;
      isReverseScored?: boolean[];
    };
  };
}

class QuestionDataLoader {
  private data: QuestionData;

  constructor() {
    // Load question data from JSON file (generated by Python script)
    this.data = questionDatabase as unknown as QuestionData;
  }

  /**
   * Normalize condition name for consistent lookups
   */
  private normalizeConditionName(name: string): string {
    return name
      .toLowerCase()
      .trim()
      .replace(/\s+/g, "")
      .replace(/[^a-z0-9]/g, "");
  }

  /**
   * Find condition data by name with fuzzy matching
   */
  private findCondition(scanName: string): string | null {
    const normalized = this.normalizeConditionName(scanName);
    const conditions = Object.keys(this.data.conditions);

    // Try exact match first
    const exactMatch = conditions.find(
      (key) => this.normalizeConditionName(key) === normalized
    );
    if (exactMatch) return exactMatch;

    // Try partial match
    const partialMatch = conditions.find(
      (key) =>
        this.normalizeConditionName(key).includes(normalized) ||
        normalized.includes(this.normalizeConditionName(key))
    );
    if (partialMatch) return partialMatch;

    return null;
  }

  /**
   * Get questions for a specific scan
   */
  getQuestionsForScan(scanName: string, locale: string): QuestionSet[] {
    const conditionKey = this.findCondition(scanName);

    if (!conditionKey) {
      console.warn(`No questions found for scan: ${scanName}`);
      return [];
    }

    const conditionData = this.data.conditions[conditionKey];
    const questions = conditionData.questions;
    const reverseScored = conditionData.isReverseScored || [];

    // Build the question structure
    const questionPairs: QuestionOption[][] = [];

    for (let i = 0; i < questions.length; i += 2) {
      const pair: QuestionOption[] = [];

      for (let j = 0; j < 2 && i + j < questions.length; j++) {
        const questionIndex = i + j;
        const question = questions[questionIndex];
        const isReverse = reverseScored[questionIndex] || false;

        const questionObj: QuestionOption = {
          filename: t(
            `scanQuestions.${this.getCamelCase(conditionKey)}.title`,
            conditionKey
          ),
          Q_id: (questionIndex + 1).toString(),
          Name: t(
            `scanQuestions.${this.getCamelCase(conditionKey)}.questions.${
              questionIndex + 1
            }`,
            question.text
          ),
          "Option 1": t(
            `scanQuestions.${this.getCamelCase(
              conditionKey
            )}.options.stronglyDisagree`,
            "Strongly Disagree"
          ),
          "Option 1 Weight": isReverse
            ? question.scores.stronglyAgree.toString()
            : question.scores.stronglyDisagree.toString(),
          "Option 2": t(
            `scanQuestions.${this.getCamelCase(
              conditionKey
            )}.options.disagree`,
            "Disagree"
          ),
          "Option 2 Weight": isReverse
            ? question.scores.agree.toString()
            : question.scores.disagree.toString(),
          "Option 3": t(
            `scanQuestions.${this.getCamelCase(conditionKey)}.options.neutral`,
            "Neutral"
          ),
          "Option 3 Weight": question.scores.neutral.toString(),
          "Option 4": t(
            `scanQuestions.${this.getCamelCase(conditionKey)}.options.agree`,
            "Agree"
          ),
          "Option 4 Weight": isReverse
            ? question.scores.disagree.toString()
            : question.scores.agree.toString(),
          "Option 5": t(
            `scanQuestions.${this.getCamelCase(
              conditionKey
            )}.options.stronglyAgree`,
            "Strongly Agree"
          ),
          "Option 5 Weight": isReverse
            ? question.scores.stronglyDisagree.toString()
            : question.scores.stronglyAgree.toString(),
        };

        pair.push(questionObj);
      }

      if (pair.length > 0) {
        questionPairs.push(pair);
      }
    }

    // Return in the expected format
    return [
      {
        [t(
          `scanQuestions.${this.getCamelCase(conditionKey)}.title`,
          conditionKey
        )]: questionPairs,
      },
    ];
  }

  /**
   * Convert string to camelCase
   */
  private getCamelCase(str: string): string {
    const words = str.split(/\s+/);
    if (words.length === 1) return words[0].toLowerCase();
    return (
      words[0].toLowerCase() +
      words
        .slice(1)
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
        .join("")
    );
  }

  /**
   * Get all available scan names
   */
  getAllScanNames(): string[] {
    return Object.keys(this.data.conditions);
  }

  /**
   * Get intro data for a scan
   */
  getIntroData(scanName: string): {
    title: string;
    overview: string;
    category?: string;
  } | null {
    const conditionKey = this.findCondition(scanName);

    if (!conditionKey) {
      return null;
    }

    const camelCase = this.getCamelCase(conditionKey);

    // Read category from the question database if present
    const conditionMeta = this.data.conditions[conditionKey] as any;
    const category = conditionMeta && conditionMeta.category ? conditionMeta.category : undefined;

    return {
      title: t(`scanIntro.${camelCase}.title`, conditionKey),
      overview: t(
        `scanIntro.${camelCase}.overview`,
        `This assessment helps evaluate ${conditionKey.toLowerCase()}.`
      ),
      category,
    };
  }
}

// Export singleton instance
export const questionDataLoader = new QuestionDataLoader();

// Export default
export default questionDataLoader;